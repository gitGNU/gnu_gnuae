// 
//   Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
// 
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

// Power Loss = Voltage drop as a percentage x load in amps
//

// This is generated by autoconf
#include "config.h"

#include <limits.h>
#include <vector>
#include <string>
#include <iostream>
#include <iomanip>
#include <fstream>
#include <cstdlib>
#include <cmath>

#include "nec_tables.h"

// #include "log.h"
// #include "err.h"
#include "NEC.h"

using namespace std;
using namespace gnuae;

extern "C" {
#if 0
  const int awglist[] = { 18, 16, 14, 12, 10, 8, 6, 4, 3, 2, 1,
                             -1, -2, -3, -4,
                             250, 300, 350, 400, 500, 600
  };
#endif
  
  /*
    NEC Table 690.7: Voltage correction factors for crystaline and
    multicrystaline silicon PV modules.
  */
  struct nec_table_690_7 _table_690_7[] =
    {
      { 25,   10, 1.06, 77, 50 },
      { 9,     0, 1.10, 49, 32 },
      { -1,  -10, 1.13, 31, 14 },
      { -11, -20, 1.17, 13, -4 },
      { -21, -40, 1.25, -5, -40 },
      {   0,   0,    0,  0,   0 }
    };
  
  /* NEC Table 8: DC resistance @ 167F (75C), 1000 feet stranded */
  struct nec_table8 _table8[] = 
    {
      { 18,   7,   1620, 0.046,  7.95,    8.45,   13.1 },
      { 16,   7,   2580, 0.058,  4.99,    5.29,   8.21 },
      { 14,   7,   4110, 0.073,  3.14,    3.26,   5.17 },
      { 12,   7,   6530, 0.92,   1.98,    2.05,   3.25 },
      { 10,   7,  10380, 0.116,  1.24,    1.29,   2.04 },
      { 8,    7,  16510, 0.146, 0.778,  0.8090,   1.28 },
      { 6,    7,  26240, 0.184, 0.491,  0.5100,  0.808 },
      { 4,    7,  41740, 0.232, 0.308,  0.3210,  0.508 },
      { 3,    7,  52620, 0.260, 0.245,  0.2540,  0.403 },
      { 2,    7,  66360, 0.292, 0.194,  0.2010,  0.319 },
      { 1,    7,  83690, 0.332, 0.154,  0.1600,  0.253 },
      { -1,  19, 105600, 0.372, 0.122,  0.1270,  0.201 },
      { -2,  19, 133100, 0.418, 0.0967, 0.1010,  0.159 },
      { -3,  19, 167800, 0.470, 0.0766, 0.0797,  0.126 },
      { -4,  19, 211600, 0.528, 0.0608, 0.0626,  0.100 },
      { 250, 37, 250000, 0.575, 0.0515, 0.0535, 0.0847 },
      { 300, 37, 300000, 0.630, 0.0429, 0.0446, 0.0707 },
      { 350, 37, 350000, 0.681, 0.0367, 0.0382, 0.0605 },
      { 400, 37, 400000, 0.728, 0.0321, 0.0331, 0.0529 },
      { 500, 37, 500000, 0.813, 0.0258, 0.0265, 0.0424 },
      { 600, 61, 600000, 0.893, 0.0214, 0.0223, 0.0353 },
      {   0,  0,      0,     0,      0,      0,      0 }
    };

  struct nec_table9 _table9[] =
    {
      {   14, { 0.058, 0.073, 0.0 }, { 3.1, 3.1, 3.1 },       { 0, 0, 0 },            { 2.7, 2.7, 2.7 },        { 0, 0, 0 } },
      {   12, { 0.054, 0.068, 0.0 }, { 2.0, 2.0, 2.0 },       { 3.2, 3.2, 3.2 },      { 1.7, 1.7, 1.7 },        { 2.8, 2.8, 2.8 } },
      {   10, { 0.050, 0.063, 0.0 }, { 1.2, 1.2, 1.2 },       { 2.0, 2.0, 2.0 },      { 1.1, 1.1, 1.1 },        { 1.8, 1.8, 1.8 } },
      {    8, { 0.052, 0.065, 0.0 }, { 0.78, 0.78, 0.78 },    { 1.3, 1.3, 1.3 },      { 0.69, 0.69, 0.69 },     { 1.1, 1.1, 1.1 } },
      {    6, { 0.051, 0.064, 0.0 }, { 0.49, 0.49, 0.49 },    { 0.81, 0.81, 0.81 },   { 0.45, 0.45, 0.45 },     { 0.71, 0.71, 0.71 } },
      {    4, { 0.048, 0.060, 0.0 }, { 0.31, 0.31, 0.31 },    { 0.51, 0.51, 0.51 },   { 0.29, 0.29, 0.29 },     { 0.46, 0.46, 0.46 } },
      {    3, { 0.047, 0.059, 0.0 }, { 0.25, 0.25, 0.25 },    { 0.40, 0.41, 0.40 },   { 0.23, 0.23, 0.23 },     { 0.37, 0.37, 0.37 } },
      {    2, { 0.045, 0.057, 0.0 }, { 0.19, 0.20, 0.20 },    { 0.32, 0.32, 0.22 },   { 0.19, 0.19, 0.20 },     { 0.30, 0.30, 0.30 } },
      {    1, { 0.046, 0.057, 0.0 }, { 0.15, 0.16, 0.16 },    { 0.25, 0.26, 0.25 },   { 0.16, 0.16, 0.16 },     { 0.24, 0.24, 0.25 } },
      {   -1, { 0.044, 0.055, 0.0 }, { 0.12, 0.12, 0.12 },    { 0.20, 0.21, 0.20 },   { 0.13, 0.13, 0.13 },     { 0.19, 0.20, 0.20 } },
      {   -2, { 0.043, 0.054, 0.0 }, { 0.10, 0.10, 0.10 },    { 0.16, 0.16, 0.16 },   { 0.11, 0.11, 0.11 },     { 0.16, 0.16, 0.16 } },
      {   -3, { 0.042, 0.052, 0.0 }, { 0.077, 0.082, 0.079 }, { 0.13, 0.13, 0.13 },   { 0.088, 0.092, 0.094 },  { 0.13, 0.13, 0.13 } },
      {   -4, { 0.041, 0.051, 0.0 }, { 0.062, 0.067, 0.063 }, { 0.10, 0.11, 0.10 },   { 0.074, 0.078, 0.080 },  { 0.11, 0.11, 0.11 } },
      {  250, { 0.041, 0.052, 0.0 }, { 0.052, 0.057, 0.054 }, { 0.085, 0.090, 0.086 }, { 0.066, 0.070, 0.073 }, { 0.094, 0.098, 0.10 } },
      {  300, { 0.041, 0.051, 0.0 }, { 0.044, 0.049, 0.045 }, { 0.071, 0.076, 0.072 }, { 0.059, 0.063, 0.065 }, { 0.082, 0.086, 0.088 } },
      {  350, { 0.040, 0.050, 0.0 }, { 0.038, 0.043, 0.039 }, { 0.061, 0.066, 0.063 }, { 0.053, 0.058, 0.060 }, { 0.073, 0.077, 0.080 } },
      {  400, { 0.040, 0.049, 0.0 }, { 0.033, 0.038, 0.035 }, { 0.054, 0.059, 0.055 }, { 0.049, 0.053, 0.056 }, { 0.066, 0.071, 0.073} },
      {  500, { 0.039, 0.048, 0.0 }, { 0.027, 0.032, 0.029 }, { 0.043, 0.048, 0.045 }, { 0.043, 0.048, 0.050 }, { 0.057, 0.061, 0.064} },
      {  600, { 0.039, 0.048, 0.0 }, { 0.023, 0.028, 0.025 }, { 0.036, 0.041, 0.038 }, { 0.040, 0.044, 0.047 }, { 0.051, 0.055, 0.058 } },
      {  750, { 0.038, 0.048, 0.0 }, { 0.019, 0.024, 0.021 }, { 0.029, 0.034, 0.031 }, { 0.036, 0.040, 0.043 }, { 0.045, 0.049, 0.052 } },
      {  0,   {   0.0,   0.0, 0.0 }, { 0.0,   0.057, 0.0 },   { 0.0,   0.090, 0.0 },   { 0.0,   0.0, 0.0 },     { 0.0, 0.0, 0.0 } },
    };

  /*
    NEC Table 310.11. This is the derating for the number of
    conductors in a conduit.
  */
  struct nec_table_310_11 _table_310_11[] =
    {
      { 4,   6, 80 },
      { 7,   9, 70 },
      { 10, 24, 70 },
      { 25, 42, 60 },
      { 43, 85, 50 },
      { 0,   0,  0 }
    };

  /*
    NEC Table 310.15(B)(2)(a). Adjustment factors for more than Three
    Current Carrying conductors in a Raceway or Cable.
  */
  struct nec_table_310_15B2 _table_310_15B2[] =
    {
      { 4,   6, 80 },
      { 7,   9, 70 },
      { 10, 20, 50 },
      { 21, 30, 45 },
      { 31, 40, 40 },
      { 41, INT_MAX, 35 },
      { 0,   0,  0 }
    };
  
  /*
    NEC Table 310.15(b)(6): Conductor types and sizes for 120/240 volt,
    3 wire, single-phase dwelling services and feeders. Conductor types
    RHH, RHW, RHW-2, THHN, THHW, THW, THW-2, THWN, THWN-2,
    XHHW. XHHW-2, SE, USE, USE-2.
  */
  struct nec_table_310_15B6 _table_310_15B6[] =
    {
      {   4,   2, 100 },
      {   3,   1, 110 },
      {   2,  -1, 125 },
      {   1,  -2, 150 },
      {  -1,  -3, 175 },
      {  -2,  -4, 200 },
      {  -3, 250, 225 },
      {  -4, 300, 250 },
      { 250, 350, 300 },
      { 350, 500, 350 },
      { 400, 600, 400 },
      { 0,     0,   0 }    
    };
  
  /*
    NEC Table 310.16: Allowable ampacities of Insulated conductors rated
    0 through 2000 volts. Not more than 3 current carrying conductors in
    raceway, cable, or buried. Based on ambient temperature of
    86F. (30C)
  */
  struct nec_table_310_16 _table_310_16[] =
    {
      { 18,   0,    0,  14 },
      { 16,   0,    0,  18 },
      { 14,   20,  20,  25 },
      { 12,   25,  25,  30 },
      { 10,   30,  35,  40 },
      {  8,   40,  50,  55 },
      {  6,   55,  65,  75 },
      {  4,   70,  85,  95 },
      {  3,   85, 115, 130 },
      {  2,   95, 115, 130 },
      {  1,  110, 130, 150 },
      { -1,  125, 150, 170 },
      { -2,  145, 175, 195 },
      { -3,  165, 200, 225 },
      { -4,  195, 230, 260 },
      {  0,    0,   0,   0 }
    };
  
  /*
    NEC Table 310.17: Allowable ampacities of Insulated conductors rated
    0 through 2000 volts in free air Based on ambient temperature of
    86F. (30C)
  */
  struct nec_table_310_16 _table_310_17[] =
    {
      { 18,   0,    0,  18 },
      { 16,   0,    0,  24 },
      { 14,   25,  30,  35 },
      { 12,   30,  35,  40 },
      { 10,   40,  50,  55 },
      {  8,   60,  70,  80 },
      {  6,   80,  95, 105 },
      {  4,  105, 125, 140 },
      {  3,  120, 145, 165 },
      {  2,  140, 170, 190 },
      {  1,  165, 230, 220 },
      { -1,  195, 265, 260 },
      { -2,  225, 310, 300 },
      { -3,  260, 360, 350 },
      { -4,  300, 230, 405 },
      {  0,    0,   0,   0 }
    };
  
  /*
    Correction factors for temperature
  */
  struct derate _derate[] =
    {
      { 21, 25, 1.08, 1.05, 1.04,  70,  77 },
      { 26, 30, 1.00, 1.00, 1.00,  79,  86 },
      { 31, 35, 0.91, 0.94, 0.96,  88,  95 },
      { 36, 40, 0.82, 0.88, 0.87,  97, 104 },
      { 41, 45, 0.71, 0.82, 0.87, 106, 113 },
      { 46, 50, 0.58, 0.75, 0.82, 115, 122 },
      { 51, 55, 0.41, 0.67, 0.76, 124, 131 },
      { 56, 60,    0, 0.58, 0.71, 133, 140 },
      { 61, 70,    0, 0.33, 0.58, 142, 158 },
      { 71, 80,    0,    0, 0.41, 160, 176 },
      {  0,  0,    0,    0,    0,  0,  0 }
    };

#if 0
struct nec_table4
{
  double tradesize;
  double id;
  double area;
  double area60;
  double wire1;
  double wire2;
  double wireover;
  
};
#endif

  // This is the conduit sizes.

  // Article 358 -- Electrical Mettalic Tubing (EMT)
  struct nec_table4 _nec_table4_emt[] =
    {
      {  0.5, 0.622,  0.304, 0.182, 0.161, 0.094, 0.122  },
      { 0.75, 0.824,  0.533, 0.320, 0.283, 0.165, 0.213  },
      {  1.0, 1.049,  0.864, 0.519, 0.458, 0.268, 0.346  },
      { 1.25, 1.380,  1.496, 0.897, 0.793, 0.464, 0.598  },
      {  1.5, 1.610,  2.036, 1.221, 1.079, 0.631, 0.814  },
      {  2.0, 2.067,  3.356, 2.013, 1.778, 1.040, 1.342  },
      {  2.5, 2.731,  5.858, 3.515, 3.105, 1.816, 2.343  },
      {  3.0, 3.356,  8.846, 5.307, 4.688, 2.742, 3.538  },
      {  3.5, 3.834, 11.545, 6.927, 6.119, 3.579, 4.618  },
      {  4.0, 4.334, 14.753, 8.852, 7.819, 4.573, 5.901  },
      {    0,     0,     0,     0,     0,     0,      0  }
    };

  // Article 362 -- Electrical Nonmetallic Tubing (ENT)
  struct nec_table4 _nec_table4_ent[] =
    {
      {  0.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      { 0.75, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  1.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      { 1.25, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  1.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  2.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  2.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  3.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  3.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  4.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {   0,     0,      0,     0,     0,     0,     0 }
    };

  // Article 348 -- Flexible Metal Conduit (FMC)
  struct nec_table4 _nec_table4_fmc[] =
    {
      {  0.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      { 0.75, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  1.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      { 1.25, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  1.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  2.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  2.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  3.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  3.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  4.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {   0,     0,      0,     0,     0,     0,     0 }
    };

  // Article 342 -- Intermediate Metal Conduit (IMC)
  struct nec_table4 _nec_table4_imc[] =
    {
      {  0.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      { 0.75, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  1.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      { 1.25, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  1.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  2.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  2.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  3.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  3.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  4.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {   0,     0,      0,     0,     0,     0,     0 }
    };

  // Article 356 -- Liquidtight Flexible Nonmetallic Conduit (LFNC-B*)
  struct nec_table4 _nec_table4_lfnc_b[] =
    {
      {  0.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      { 0.75, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  1.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      { 1.25, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  1.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  2.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  2.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  3.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  3.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  4.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {   0,     0,      0,     0,     0,     0,     0 }
    };
  
  // Article 356 -- Liquidtight Flexible Nonmetallic Conduit (LFNC-A*)
  struct nec_table4 _nec_table4_lfnc_a[] =
    {
      {  0.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      { 0.75, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  1.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      { 1.25, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  1.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  2.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  2.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  3.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  3.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  4.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {   0,     0,      0,     0,     0,     0,     0 }
    };
  
  // Article 350 -- Liquidtight Flexible Nonmetallic Conduit (LFMC)
  struct nec_table4 _nec_table4_lfmc[] =
    {
      {  0.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      { 0.75, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  1.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      { 1.25, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  1.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  2.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  2.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  3.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  3.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  4.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {   0,     0,      0,     0,     0,     0,     0 }
    };

  // Article 344 -- Ridig Metal Conduit (RMC)
  struct nec_table4 _nec_table4_rmc[] =
    {
      {  0.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      { 0.75, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  1.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      { 1.25, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  1.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  2.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  2.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  3.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  3.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  4.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {   0,     0,      0,     0,     0,     0,     0 }
    };

  // Article 352 -- Rigid PVC Conduit (RNC)
  struct nec_table4 _nec_table4_rnc[] =
    {
      {  0.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      { 0.75, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  1.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      { 1.25, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  1.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  2.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  2.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  3.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  3.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  4.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {   0,     0,      0,     0,     0,     0,     0 }
    };
  
  // Article 352 -- Rigid PVC Conduit (RNC), Schedule 80
  struct nec_table4 _nec_table4_pvc_80[] =
    {
      {  0.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      { 0.75, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  1.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      { 1.25, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  1.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  2.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  2.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  3.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  3.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  4.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {   0,     0,      0,     0,     0,     0,     0 }
    };
  
  // Article 352 -- Rigid PVC Conduit (RNC), Schedule 40
  struct nec_table4 _nec_table4_pvc_40[] =
    {
      {  0.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      { 0.75, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  1.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      { 1.25, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  1.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  2.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  2.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  3.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  3.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  4.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {   0,     0,      0,     0,     0,     0,     0 }
    };
  
  // Article 352 -- Rigid PVC Conduit (RNC), type A
  struct nec_table4 _nec_table4_pvc_a[] =
    {
      {  0.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      { 0.75, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  1.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      { 1.25, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  1.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  2.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  2.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  3.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  3.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  4.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {   0,     0,      0,     0,     0,     0,     0 }
    };
  
  // Article 352 -- Rigid PVC Conduit (RNC), type EB
  struct nec_table4 _nec_table4_pvc_eb[] =
    {
      {  0.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      { 0.75, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  1.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      { 1.25, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  1.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  2.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  2.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  3.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  3.5, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {  4.0, 0.000,  0.000, 0.000, 0.000, 0.000, 0.000 },
      {   0,     0,      0,     0,     0,     0,     0 }
    };

  struct nec_table4 *_nec_table4s[] =
    {
      _nec_table4_emt,
      _nec_table4_ent,
      _nec_table4_fmc,
      _nec_table4_imc,
      _nec_table4_lfnc_b,
      _nec_table4_lfnc_a,
      _nec_table4_lfmc,
      _nec_table4_rmc,
      _nec_table4_rnc,
      _nec_table4_pvc_80,
      _nec_table4_pvc_40,
      _nec_table4_pvc_a,
      _nec_table4_pvc_eb
    };
  
  // NEC Table 5. Dimensions of Insulated Conductors and Fixture Wires
  struct nec_table5 _nec_table5[] =
    {      
      { RHH|RHW|RHW2,  14, 0.193, 0.0293 },
      { RHH|RHW|RHW2,  12, 0.212, 0.0353 },
      { RHH|RHW|RHW2,  10, 0.236, 0.0437 },
      { RHH|RHW|RHW2,   8, 0.326, 0.0835 },
      { RHH|RHW|RHW2,   6, 0.364, 0.1041 },
      { RHH|RHW|RHW2,   4, 0.412, 0.1333 },
      { RHH|RHW|RHW2,   3, 0.440, 0.1521 },
      { RHH|RHW|RHW2,   2, 0.472, 0.1750 },
      { RHH|RHW|RHW2,   1, 0.582, 0.2660 },
      { RHH|RHW|RHW2,  -1, 0.622, 0.3039 },
      { RHH|RHW|RHW2,  -2, 0.668, 0.3505 },
      { RHH|RHW|RHW2,  -3, 0.720, 0.4072 },
      { RHH|RHW|RHW2,  -4, 0.778, 0.4754 },
      { RHH|RHW|RHW2, 250, 0.895, 0.6291 },
      { RHH|RHW|RHW2, 300, 0.950, 0.7088 },
      { RHH|RHW|RHW2, 350, 1.001, 0.7870 },
      { RHH|RHW|RHW2, 400, 1.048, 0.8626 },
      { RHH|RHW|RHW2, 500, 1.133, 1.0082 },
      { RHH|RHW|RHW2, 600, 1.243, 1.2135 },

      { TW|THHW|THW|THW2, 14, 0.133, 0.0139 },
      { TW|THHW|THW|THW2, 12, 0.152, 0.0181 },
      { TW|THHW|THW|THW2, 10, 0.176, 0.0243 },
      { TW|THHW|THW|THW2,  8, 0.236, 0.0437 },

      { RHH|RHW|RHW2, 14, 0.163, 0.0209 },
      { RHH|RHW|RHW2, 12, 0.182, 0.0260 },
      { RHH|RHW|RHW2, 10, 0.206, 0.0333 },
      { RHH|RHW|RHW2,  8, 0.266, 0.0556 },

      { TW|THHW|THW|THW2|RHH|RHW|RHW2,    6, 0.304, 0.0726 },
      { TW|THHW|THW|THW2|RHH|RHW|RHW2,    4, 0.352, 0.0973 },
      { TW|THHW|THW|THW2|RHH|RHW|RHW2,    3, 0.380, 0.1134 },
      { TW|THHW|THW|THW2|RHH|RHW|RHW2,    2, 0.412, 0.1333 },
      { TW|THHW|THW|THW2|RHH|RHW|RHW2,    1, 0.492, 0.1901 },
      { TW|THHW|THW|THW2|RHH|RHW|RHW2,   -1, 0.532, 0.2223 },
      { TW|THHW|THW|THW2|RHH|RHW|RHW2,   -2, 0.578, 0.2624 },
      { TW|THHW|THW|THW2|RHH|RHW|RHW2,   -3, 0.630, 0.3117 },
      { TW|THHW|THW|THW2|RHH|RHW|RHW2,   -4, 0.688, 0.3718 },
      { TW|THHW|THW|THW2|RHH|RHW|RHW2,  250, 0.765, 0.4596 },
      { TW|THHW|THW|THW2|RHH|RHW|RHW2,  300, 0.820, 0.5281 },
      { TW|THHW|THW|THW2|RHH|RHW|RHW2,  350, 0.871, 0.5958 },
      { TW|THHW|THW|THW2|RHH|RHW|RHW2,  400, 0.918, 0.6619 },
      { TW|THHW|THW|THW2|RHH|RHW|RHW2,  500, 1.003, 0.7901 },
      { TW|THHW|THW|THW2|RHH|RHW|RHW2,  600, 1.113, 0.9729 },
      
      { THHN|THWN|THWN2,  14, 0.111, 0.0097 },
      { THHN|THWN|THWN2,  12, 0.130, 0.0133 },
      { THHN|THWN|THWN2,  10, 0.164, 0.0211 },
      { THHN|THWN|THWN2,   8, 0.216, 0.0366 },
      { THHN|THWN|THWN2,   6, 0.254, 0.0507 },
      { THHN|THWN|THWN2,   4, 0.324, 0.0824 },
      { THHN|THWN|THWN2,   3, 0.352, 0.0973 },
      { THHN|THWN|THWN2,   2, 0.384, 0.1158 },
      { THHN|THWN|THWN2,   1, 0.446, 0.1562 },
      { THHN|THWN|THWN2,  -1, 0.486, 0.1855 },
      { THHN|THWN|THWN2,  -2, 0.532, 0.2223 },
      { THHN|THWN|THWN2,  -3, 0.584, 0.2679 },
      { THHN|THWN|THWN2,  -4, 0.642, 0.3237 },
      { THHN|THWN|THWN2, 250, 0.711, 0.3970 },
      { THHN|THWN|THWN2, 300, 0.766, 0.4608 },
      { THHN|THWN|THWN2, 350, 0.817, 0.5424 },
      { THHN|THWN|THWN2, 400, 0.864, 0.5863 },
      { THHN|THWN|THWN2, 500, 0.949, 0.7073 },
      { THHN|THWN|THWN2, 600, 1.051, 0.8676 },

      { XHHW|XHHW2|XHH,  14, 0.122, 0.0139 },
      { XHHW|XHHW2|XHH,  12, 0.152, 0.0181 },
      { XHHW|XHHW2|XHH,  10, 0.176, 0.0243 },
      { XHHW|XHHW2|XHH,   8, 0.236, 0.0437 },
      { XHHW|XHHW2|XHH,   6, 0.274, 0.0590 },
      { XHHW|XHHW2|XHH,   4, 0.322, 0.0814 },
      { XHHW|XHHW2|XHH,   3, 0.350, 0.0962 },
      { XHHW|XHHW2|XHH,   2, 0.382, 0.1146 },
      { XHHW|XHHW2|XHH,   1, 0.442, 0.1534 },
      { XHHW|XHHW2|XHH,  -1, 0.482, 0.1825 },
      { XHHW|XHHW2|XHH,  -2, 0.528, 0.2190 },
      { XHHW|XHHW2|XHH,  -3, 0.580, 0.2642 },
      { XHHW|XHHW2|XHH,  -4, 0.638, 0.3197 },
      { XHHW|XHHW2|XHH, 250, 0.705, 0.3904 },
      { XHHW|XHHW2|XHH, 300, 0.760, 0.4536 },
      { XHHW|XHHW2|XHH, 350, 0.811, 0.5166 },
      { XHHW|XHHW2|XHH, 400, 0.858, 0.5782 },
      { XHHW|XHHW2|XHH, 500, 0.943, 0.6984 },
      { XHHW|XHHW2|XHH, 600, 1.053, 0.8709 },
      {              0,   0,     0,      0 }
    };
  
  /*
    NEC Table 690.31(C): Temperature correction factors for flexible
    cables on the moving parts of a tracking PV array.
  */
  struct nec_table_690_31C _table_690_31C[] =
    {
      {  0, 30,  1.0,  1.0,  1.0,  1.0,   0,  86 },
      { 31, 35, 0.91, 0.94, 0.96, 0.97,  87,  95 },
      { 36, 40, 0.82, 0.88, 0.91, 0.93,  96, 104 },
      { 41, 45, 0.71, 0.82, 0.87, 0.89, 105, 113 },
      { 46, 50, 0.58, 0.75, 0.82, 0.86, 114, 122 },
      { 51, 55, 0.41, 0.67, 0.76, 0.82, 123, 131 },
      { 56, 60,    0, 0.58, 0.71, 0.77, 132, 140 },
      { 61, 70,    0, 0.33, 0.58, 0.68, 141, 158 },
      { 71, 80,    0,    0, 0.41, 0.58, 159, 176 },
      {  0,  0,    0,    0,    0,  0,  0 }
    };  
} // end of extern "C"


// extern LogFile dbglog;

// Most wire anyone deals with is the uncoated type, copper. We want
// to use the exactK for all calculations. If we use conduit, assume
// it's EMT.
NEC::NEC(void): _coated(false), _debug(false),  _exact(true),
                _celcius(false), _wiretype(NOTYPE), _wiremetal(COPPER),
                _conduit(EMT)
{
}

NEC::~NEC(void)
{
  // There is nothing to destruct
}

// This calculates the proper fuse size for a circuit
double
NEC::fuseSize(double amps)
{
  return ampacity(amps);
}

double
NEC::breakerSize(double amperage)
{
  return amperage * MAXCURRENT;
}

double
NEC::ampacity(void)
{
  return MAXAMPICITY;
}

double
NEC::ampacity(double amps)
{
  return amps * MAXAMPICITY;
}

double
NEC::maxCurrent(void)
{
  return MAXCURRENT;
}

double
NEC::maxCurrent(double amps)
{
  return amps * MAXCURRENT;
}

double
NEC::overCurrent(double amps)
{
  return amps * MAXCURRENT;
}

double
NEC::overCurrent(int strings, double isc)
{
  return (isc * strings) * MAXCURRENT;
}

double
NEC::crystalCompensation(double temp)
{
  int i;
  double compfactor;
  
  for (i=0; _table_690_7[i].hightempC != 0; i++) {
    if (_celcius) {
      if ((temp <_table_690_7[i].hightempC ) && (temp > _table_690_7[i].lowtempC)) {
        compfactor = _table_690_7[i].compensation;
        break;
      }
    } else {
      if ((temp < _table_690_7[i].hightempF ) && (temp > _table_690_7[i].lowtempF)) {
        compfactor = _table_690_7[i].compensation;
        break;
      }
    }
    if (_celcius){
      if (temp > _table_690_7[i].hightempC) {
        compfactor = _table_690_7[i].compensation;
        break;
      }
    } else {
      if (temp > _table_690_7[i].hightempF) {
        compfactor = _table_690_7[i].compensation;
        break;
      }
    }
  }

  if (_debug)
    cerr << "Temp compensation for temp " << temp << " is: "
         << compfactor  << endl;

  return compfactor;
}

double
NEC::crystalCompensation(double voltage, double temp)
{
  double nvolts;
  
  nvolts = crystalCompensation(temp) * voltage;
  
  if (_debug)
    cerr << "The temperature adjusted voltage is: " << nvolts << endl;
      
  return nvolts;
}

double
NEC::resistance(int awg)
{
  return resistance(awg, NOMINALTEMP);
}

//
// Formula for temperature change: R2 = R1 * (1 + (a * (T2 - 75)))
// where Acu = 0.00323, Aal = 0.00330 at 75°C.
//
double
NEC::resistance(int awg, double temp)
{
  int i;
  double res, k;

  if (_debug)
    cerr << "Looking up the resistance from NEC Table 8 for gauge #"
         << awg << " at temperature " << temp << "F" << endl;
  

  // Lookup the resistance value from NEC table 8
  for (i=0; _table8[i].awg != 0; i++) {
    if (awg == _table8[i].awg) {
      if (_coated) {
        res = _table8[i].coated;
        break;
      }
      else {
        res = _table8[i].uncoated;
        break;
      }
    }
  }
  
  if (_debug)
    cerr << "The resistance from NEC Table 8 for 1000ft is\t" << res << endl;

  if (_celcius)
    res = res + (COPPERTEMP * temp * res) - (COPPERTEMP * NOMINALTEMP * res);
  else
    res = res + (COPPERTEMP * celcius(temp) * res) - (COPPERTEMP * NOMINALTEMP * res);  
  
  if (_debug) {
    cerr << "The temperature adjusted resistance for 1000ft is\t" << res << endl;
  }

  return res;
}

double
NEC::resistance(int awg, double temperature, bool exact)
{
  cerr <<  __PRETTY_FUNCTION__ << " Unimplemented" << endl;
}

double
NEC::resistance(int awg, double temperature, wiremetal_t type)
{
  cerr <<  __PRETTY_FUNCTION__ << " Unimplemented" << endl;
}

double
NEC::resistance(int awg, double temperature, wiremetal_t type, bool exact)
{
  cerr <<  __PRETTY_FUNCTION__ << " Unimplemented" << endl;
}


// Calculate the K value if specified
double
NEC::calcK(int awg, double temp)
{
  return calcK(awg, temp, _exact);
}

double
NEC::calcK(int awg, double temp, bool exact)
{
  int i;
  double k = 0.0;
  double mils, res;

  //  cerr << __PRETTY_FUNCTION__ << ": awg = " << awg << ", temp = " << temp << endl;

  if (exact) {
    // Calculate the exact resistance value
    for (i=0; _table8[i].awg != 0; i++) {
      if (awg == _table8[i].awg) {
        res = resistance(awg, temp);
        mils = _table8[i].mils;
        k = res * mils / 1000.0;
        break;
      }
    }
  }
  else {
    k = COPPERDROP;
  }

  if (_debug) {
    if (exact) 
      cerr << "The exact K is:\t" << k << endl;
    else
      cerr << "The approximate K is:\t" << k << endl;
  }
  
  return k;
}

double
NEC::calcK(int awg, double temp, wiretype_t type)
{
  cerr <<  __PRETTY_FUNCTION__ << " Unimplemented" << endl;
}

double
NEC::calcK(int awg, double temp, wiretype_t type, bool exact)
{
  cerr <<  __PRETTY_FUNCTION__ << " Unimplemented" << endl;
}

double
NEC::voltDrop(int awg, int distance, double volts, double amps)
{
  return voltDrop(awg, distance, volts, amps, NOMINALTEMP, 1);
}

double
NEC::voltDrop(int awg, int distance, double volts, double amps, int conductors)
{
  return voltDrop(awg, distance, volts, amps, NOMINALTEMP, conductors);
}

double
NEC::voltDrop(int awg, int distance, double volts, double amps, double temp, int conductors)
{
  int i;
  double drop;
  double length;

  length = distance;
  
  //  drop = (loss / volts) * 100;
  for (i=0; _table8[i].awg != 0; i++) {
    if (awg == _table8[i].awg) {
      drop = (2.0 * calcK(awg, temp) * length * (amps/conductors)) / _table8[i].mils;
      break;
    }
  }

  drop = (drop/volts) * 100;
  
  if (_debug) {
    cerr << "The voltage drop using table 8 is\t" << setprecision(4)
         << drop << "%" << endl;
  }
    
  return drop;
}

double
NEC::voltDrop(int awg, int distance, double volts, double amps, double temp,
              int conductors, wiremetal_t type)
{
  cerr <<  __PRETTY_FUNCTION__ << " Unimplemented" << endl;
}

double
NEC::voltLoss(int distance, int awg, double amps)
{
  return voltLoss(distance, awg, amps, NOMINALTEMP, 1);
}

double
NEC::voltLoss(int distance, int awg, double amps, int conductors)
{
  return voltLoss(distance, awg, amps, NOMINALTEMP, conductors);
}

double
NEC::voltLoss(int distance, int awg, double amps, double temp, int conductors)
{
  double res;
  double volts;
  
  if (_debug)
    cerr << "The voltage loss using Table 8 for distance is " << distance
         << "ft, awg is " << awg << ", amps is " << amps << ", temp is "
         << temp << endl;

  //  res = ((2 * resistance(awg, temp)) *distance * amps) / 7;
  
  res = ((resistance(awg, temp) * (distance * 2)) / 1000);

  volts = res * (amps/conductors);
  
  if (_debug)
    cerr << "The voltage loss using Table 8 is " << setprecision(4) << res
         << " Ohms, for a loss of " << volts << " volts " << endl;
  
  return volts;
}

double
NEC::voltLoss(int distance, int awg, double amps, double temp, int conductors,
              wiremetal_t type)
{
  cerr <<  __PRETTY_FUNCTION__ << " Unimplemented" << endl;
}

// These are just convienince methods for basic calculations
double
NEC::watts(double volts, double amps)
{
  double watts;

  watts = volts * amps;
  
  if (_debug)
    cerr << "The calculated wattage is\t" << watts << endl;

  return watts;
}

double
NEC::amps(double watts, double volts)
{
  double amps;

  amps = watts/volts;

  if (_debug)
    cerr << "The calculated amperage is\t" << amps << endl;

  return amps;
}

double
NEC::volts(double watts, double amps)
{
  double volts;

  amps = watts/volts;

  if (_debug)
    cerr << "The calculated voltage is\t" << volts << endl;

  return volts;
}


int
NEC::findGauge(int distance, double volts, double amps)
{
  return findGauge(distance, volts, amps, NOMINALTEMP, ACCEPTABLE_DROP, 1);
}

int
NEC::findGauge(int distance, double volts, double amps, double temp, int conductors)
{
  return findGauge(distance, volts, amps, temp, ACCEPTABLE_DROP, conductors);
}

int
NEC::findGauge(int distance, double volts, double amps, int conductors)
{
  return findGauge(distance, volts, amps, NOMINALTEMP, ACCEPTABLE_DROP, conductors);
}

int
NEC::findGauge(int distance, double volts, double amps, double temp, double drop, int conductors)
{

  double cmils, calcdrop;
  int  i, index;

  if (_debug) {
    cerr << "Trying to find the gauge for: distance = " << distance
         << " voltage = " << volts
         << " amperage = " << amps
         << " temperature = " << temp
         << endl;
  }

  cmils = (((COPPERDROP * (distance * 2)) * (amps/conductors)) / drop);
  
  if (_debug)
    cerr << "Calculated Mils are\t" << cmils << endl;

  // FIXME: do temperature compensation here
  //  cmils = (int)((1 + (temp - NOMINALTEMP) * COPPERTEMP) * cmils);

  if (_debug)
    cerr << "The temperature adjusted cmils is\t" << cmils << endl;

  for (i=0; _table8[i].awg != 0; i++) {
    if (_table8[i].mils > cmils) {
      index = i;
      while ((calcdrop = voltDrop(_table8[index].awg, distance, volts, amps,
                                 temp, conductors)) > drop) {
        if (_debug)
          cerr << "Calculated Voltage Drop too large at " << calcdrop << endl;
        index++;
      }

      if (_debug)
        cerr << "Calculated gauge is AWG #" << _table8[index].awg << endl;
      
      return _table8[index].awg;
    }
  }
  
  // If we get here, we have an error. Return 0, since there no such thing
  // as zero gauge wire. This means the values are off the chart.
  return 0;
}

int
NEC::findGauge(int distance, double volts, double amps, double temp, double drop,
               int conductors, wiremetal_t type)
{
  cerr <<  __PRETTY_FUNCTION__ << " Unimplemented" << endl;
}

// Find the size (diameter) of the specified conduit type and wire
// gauge for the specified number of conductors.
double
NEC::findConduit(int awg)
{
  findConduit(awg, 1, _wiretype, _conduit);
}

double
NEC::findConduit(int awg, int conductors)
{
  findConduit(awg, conductors, _wiretype, _conduit);
}

double
NEC::findConduit(int awg, int conductors, wiretype_t wire, conduit_type_t conduit)
{
  double wirearea, conduit_area;
  struct nec_table4 *table;
  int i;

  // Each circuit has two wires, one a conductor. So for each
  // conductor we have another wire to use when sizing conduit.
  conductors *= 2;
  
  for (i=0; _nec_table5[i].awg != 0; i++) {
    if (_nec_table5[i].awg == awg) {
      if (_nec_table5[i].type & wire) {
        wirearea = _nec_table5[i].area * conductors;
        if (_debug)
          cerr << "Area for " << conductors << " conductors of #" << awg
               << " AWG is " << wirearea << endl;
        break;
      }
    }
  }
  
  table =  _nec_table4_emt;

  for (i=0; table[i].tradesize != 0; i++){
    switch (conductors) {
    case 1:
      conduit_area = table[i].wire1;
      break;      
    case 2:
      conduit_area = table[i].wire2;
      break;
    default:
      conduit_area = table[i].wireover;
      break;
    };
    
    if (wirearea < conduit_area ) {
      if (_debug)
        cerr << "Conduit size is " << table[i].tradesize
             << " Area is " << conduit_area << endl;
      return table[i].tradesize;
    }
  }

  return 0;
}

void
NEC::toggleExact(bool val)
{
  _exact = val;
}

void
NEC::toggleDebug(bool val)
{
  _debug = val;
}

void
NEC::dump(void)
{
  int i;
  
  if (_coated == true) {
    cerr << "The wire is coated" << endl << endl;
  }
  else {
    cerr << "The wire is uncoated" << endl << endl;
  }

#if 0
  // Dump the wire gauge
  for (i=0; _table8[i].awg != 0; i++) {
    if (_table8[i].awg > 0) {
      cerr << "AWG is #" << _table8[i].awg << endl;
    }
    else {
      cerr << "AWG is #" << abs(_table8[i].awg) << "/0" << endl;
    }
    cerr << "This gauge wire has " << _table8[i].conductors << endl;
    cerr << "Mils for this gauge is " << _table8[i].mils << endl;
    cerr << "Coated resistance is " << _table8[i].uncoated << endl;
    cerr << "Uncoated resistance is " << _table8[i].coated << endl;
  }

#else
  //  cerr.setf(ios::left);

  int cw = 10;

  // Print the header
  cerr << "AWG";
  cerr << setw(cw) << "Strands";
  cerr << setw(cw) << "Mils";
  cerr << setw(cw) << "Dia";
  cerr << setw(cw) << "Uncoated";
  cerr << setw(cw) << "Coated" << endl;
  cerr << setw((cw*3)+3) << "(Inches)";
  cerr << setw(cw) << "Ohms";
  cerr << setw(cw) << "Ohms" << endl;
  // Print a line
  for (i=0; i<=52; i++)
    cerr << "-";
  cerr << endl;
  
  for (i=0; _table8[i].awg != 0; i++) {
    if (_table8[i].awg > 0) {
      cerr << setw(3) <<_table8[i].awg;
    }
    else {
      cerr << setw(1) << abs(_table8[i].awg) << "/0";
    }
    cerr << setw(cw) << _table8[i].conductors;
    if (_table8[i].mils < 0)      
      cerr << setw(cw) << "-";
    else
      cerr << setw(cw) << _table8[i].mils;

    // We want to have trailing zeros so everything lines up nicely
    cerr.setf(ios::fixed);
    cerr.precision(4);

    cerr << setw(cw) << _table8[i].dia;
    cerr << setw(cw) << _table8[i].uncoated;
    cerr << setw(cw) << _table8[i].coated << endl;
  }

  cerr << endl << "The Correction factors for Crystaline Modules is:" <<
    endl << endl;

  cerr << "Ambient\t\tCorrection\tAmbient" << endl;
  cerr << "Temp C\t\tFactor\t\tTemp F" << endl;
  cerr << "-------\t\t----------\t-------" << endl;

  for (i=0; _table_690_7[i].hightempC != 0; i++) {
    cerr << setw(3) << _table_690_7[i].hightempC << " to " << setw(3)
         << _table_690_7[i].lowtempC;
    cerr << "\t" << setw(3) << _table_690_7[i].compensation;
    cerr << "\t\t" << setw(3) << _table_690_7[i].hightempF << " to " <<
      setw(3) << _table_690_7[i].lowtempF << endl;
  }

  cerr << endl << "NEC Table 310.16" << endl << endl;

  cerr << "Ambient" << setw(64) << "Ambient" << endl;
  cerr << "Temp C\t\t60C(150F)\t75C(167F)\t90C(194F)\tTemp F" << endl;
  cerr << setw(23) << "Types"
       << setw(16) << "Types"
       << setw(16) << "Types" << endl;
  cerr << setw(23) << "TW"
       << setw(16) << "THHW"
       << setw(16) << "RHH" << endl;
  
  cerr << setw(23) << "UF"
       << setw(16) << "THW"
       << setw(16) << "THHN" << endl;
  
  cerr << setw(39) << "THWN"
       << setw(16) << "XHHW" << endl;
  
  cerr << setw(39) << "XHHW"
       << setw(16) << "THWN-2" << endl;
  
  cerr << setw(39) << "USE"
       << setw(16) << "XHRW-2" << endl;
  
  cerr << setw(55) << "RHW-2" << endl;
  
  cerr << setw(55) << "USE-2" << endl;
  
  cerr << "-------\t\t---------\t---------\t----------\t-----------" << endl;  
  for (i=0; _derate[i].hightempC != 0; i++) {
    cerr << setw(3) << _derate[i].hightempC << " to " << setw(3)
         << _derate[i].lowtempC;
    cerr << setw(12) << _derate[i].R60C_140F;
    cerr << setw(16) << _derate[i].R75C_167F;
    cerr << setw(18) << _derate[i].R90C_194F;
    cerr << setw(12) << _derate[i].hightempF << " to " << setw(3)
         << _derate[i].lowtempF << endl;
  }
#endif
}

// Return the Celcius equivalant of a Farenheit temperature
double
NEC::celcius(double temp)
{
  double val;
  
  val = (5.0/9.0) * (temp - 32.0);

  //  cerr << temp << "F equals " << val << "C" << endl;
  
  return val;
}

// Return the Farenheit equivalant of a Celcius temperature
double
NEC::farenheit(double temp)
{
  double val;
  
  val = (9/5 * temp) + 32;

  //  cerr << temp << "C equals " << val << "F" << endl;
  
  return val;
}

int
NEC::findGround(double volts, double amps)
{
  return findGauge(50, volts, amps);
}

int
NEC::awgPV2PV(int distance, double volts, double amps, double temp, int conductors)
{
  amps = ampacity(amps);
  amps = crystalCompensation(amps);

  return findGauge(distance, volts, amps, temp, 2.0, conductors);
}

int
NEC::awgPV2Combiner(int distance, double volts, double amps, double temp, int conductors)
{
  
  amps = ampacity(amps);
  amps = crystalCompensation(amps);

  return findGauge(distance, volts, amps, temp, 2.0, conductors);
}

int
NEC::awgCombiner2Charger(int distance, double volts, double amps, double temp, int conductors)
{
  return findGauge(distance, volts, amps, temp, 2.0, conductors);
}

int
NEC::awgWind2Charger(int distance, double volts, double amps, double temp, int conductors)
{
  return findGauge(distance, volts, amps, temp, conductors);
}

int
NEC::awgCharger2Battery(int distance, double volts, double amps, double temp, int conductors)
{
  return findGauge(distance, volts, amps, temp, conductors);
}


int
NEC::awgBattery2Inverter(int distance, double volts, double amps, double temp, int conductors)
{
  return findGauge(distance, volts, amps, temp, conductors);
}

// Calculate the ampacity of a conductor based on the number of
// conductors in free air or in conduit.
double
NEC::wireAmpacity(int awg, int temp, int conductors, bool conduit,
                  wiretype_t type)
{
  int i;
  double factor;
  nec_table_310_16 *table;

  // default to free air, no conduit
  table = _table_310_17;
  factor = 1;

  // Get the correction factor for the number of conductors in a
  // conduit
  if (conduit) {
    table = _table_310_16;
    if (conductors > 3) {
      for (i=0; _table_310_15B2[i].lowconductors != 0; i++) {
        if ((conductors >= _table_310_15B2[i].lowconductors) &&
            (conductors <= _table_310_15B2[i].highconductors)) {
          factor = _table_310_15B2[i].adjust / 100;
        }
      }
    }
  }
  
  // Adjust for temperature
  if (temp <= _derate[0].lowtempF) {
    if ((type & TW) || (type & UF)) {
        factor *= _derate[0].R60C_140F;
    }
    if ((type & RHW)  || (type & THHW) ||
        (type & THW)  || (type & THWN) ||
        (type & XHHW) || (type & USE)) {
      factor *= _derate[0].R75C_167F;
    }
    factor *= _derate[0].R90C_194F;
  }

  if (temp > _derate[0].lowtempF) {
    for (i=0; _derate[i].lowtempF != 0; i++) {
      if ((temp >= _derate[i].lowtempF) && (temp <= _derate[i].hightempF)) {
        if ((type & TW) || (type & UF)) {
          factor *= _derate[i].R60C_140F;
          break;
        }
        if ((type & RHW)  || (type & THHW) ||
            (type & THW)  || (type & THWN) ||
            (type & XHHW) || (type & USE)) {
          factor *= _derate[i].R75C_167F;
          break;
        }
        factor *= _derate[i].R90C_194F;
        break;
      }
    }
  }

  // If it's over our high temperature
  if (temp > _derate[9].hightempF) {
    return -1.0;
  }
  
  // Find the adjustment value
  for (i=0; table[i].awg != 0; i++) {
    if (awg == table[i].awg) {
      if ((type & TW) || (type & UF)) {
        return table[i].R60C_140F * factor;
      }
      if ((type & RHW)  || (type & THHW) ||
          (type & THW)  || (type & THWN) ||
          (type & XHHW) || (type & USE)) {
        return table[i].R75C_167F * factor;
      }
      return table[i].R90C_194F * factor;
    }
  }

  return -1.0;
}



// This is for the C API. We have to instantiate a class for the C API
// code to operate on.
gnuae::NEC _nec;

extern "C" {
    /* The C API goes here */
    void nec_toggle_debug(int val)
    {
	_nec.toggleDebug(val);
    }
    
    double nec_volt_drop(int awg, int distance, double volts, double amps, double temp,
			int conductors)
    {
	return _nec.voltDrop(awg, distance, volts, amps, temp, conductors);
    }
    
    double nec_volt_loss(int distance, int awg, double amps, double temperature,
			int conductors)
    {
	return _nec.voltLoss(distance, awg, amps, temperature, conductors);
    }
    
    double nec_watts(double volts, double amps)
    {
	return _nec.watts(volts, amps);
    }
    
    double nec_amps(double watts, double volts)
    {
	return _nec.amps(watts, volts);
    }
    
    double nec_volts(double watts, double amps)
    {
	return _nec.volts(watts, amps);
    }
    
    double nec_resistance(int awg, double temperature)
    {
	return _nec.resistance(awg, temperature);
    }
    
    double nec_wire_derate(int awg, double temperature)
    {
	//    return _nec.wireDerate(awg, temperature);
    }
    
    double nec_over_current(int strings, double isc)
    {
	return _nec.overCurrent(strings, isc);
    }
    
    int nec_find_gauge(int distance, double volts, double amps, double temp,
		       int conductors)
    {
	return _nec.findGauge(distance, volts, amps, temp, conductors);
    }
    int nec_find_ground(double volts, double amps) 
    {
	return _nec.findGround(volts, amps);
    }
    
    double nec_crystal_comp(double temp)
    {
	return _nec.crystalCompensation(temp);
    }
    
    int nec_awg_pv2pv(int distance, double volts, double amps, double temp,
		      int conductors)
    {
	return _nec.awgPV2PV(distance, volts, amps, temp, conductors);
    }
    
    int nec_awg_pv2combiner(int distance, double volts, double amps, double temp,
			    int conductors)
    {
	return _nec.awgPV2Combiner(distance, volts, amps, temp, conductors);
    }
    
    int nec_awg_combiner2charger(int distance, double volts, double amps, double temp,
				 int conductors)
    {
	return _nec.awgCombiner2Charger(distance, volts, amps, temp, conductors);
    }
    
    int nec_awg_wind2charger(int distance, double volts, double amps, double temp,
			     int conductors)
    {
	return _nec.awgWind2Charger(distance, volts, amps, temp, conductors);
    }
    
    int nec_awg_charger2battery(int distance, double volts, double amps, double temp,
				int conductors)
    {
	return _nec.awgCharger2Battery(distance, volts, amps, temp, conductors);
    }
    
    
    int nec_awg_battery2inverter(int distance, double volts, double amps, double temp,
				 int conductors)
    {
	return _nec.awgBattery2Inverter(distance, volts, amps, temp, conductors);
    }
    
    double nec_wire_ampacity(int awg, int temp, int conductors, int conduit,
			    wiretype_t type)
    {
	return _nec.wireAmpacity(awg, temp, conductors, conduit, type);
    }
    
    double nec_ampacity(double amps)
    {
	return _nec.ampacity(amps);
    }
    
    double nec_find_conduit(int awg, int conductors, wiretype_t wire, conduit_type_t conduit)
    {
	return _nec.findConduit(awg, conductors, wire, conduit);
    }
    
    int list_names(char *str)
    {
	
    }
}

// local Variables:
// mode: C++
// indent-tabs-mode: t
// End:
