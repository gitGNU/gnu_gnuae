// 
//   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008,
//              2009, 2010 Free Software Foundation, Inc.
// 
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

// Power Loss = Voltage drop as a percentage x load in amps
//

// This is generated by autoconf
#include "config.h"

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h> 
#include <iostream>
#include <fstream>
#include <map>
#include <memory>
#include <vector>
#include <string>
#include <cstdlib>
#include <cstring>
#include <iterator>
#include <cmath>
#ifdef __STDC_HOSTED__
#include <sstream>
#else
#include <strstream>
#endif

#include "Loads.h"
#include "log.h"
#include "gnuae.h"

using namespace std;
namespace gnuae {

static LogFile& dbglogfile = LogFile::getDefaultInstance();
static GnuAE& gdata = GnuAE::getDefaultInstance();

extern "C" {
  const char *load_strs[] =  {
    "NOLOAD",
    "AC",
    "DC"
  };
  
  const char *loadgroup_strs[]= {
  "NOGROUP",
  "HOUSEHOLD",
  "TOOLS",
  "KITCHEN",
  "DIGITAL"
  };

  const int LINELEN = 1024;
  const int FIELDLEN = 512;
};

Loads::Loads(void)
{    
  
}

Loads::~Loads(void)
{
    if (_data.size()) {
	std::map<std::string, load_t *>::const_iterator it;
	for (it = _data.begin(); it != _data.end(); it++) {
	    load_t *entry = it->second;
	    if (entry) {
		//std::cerr << "Deleting: " << entry->description << std::endl;
		if (entry->description) {
		    free(entry->description);
		}
	    }
	}
    }
}

void
Loads::dump(void)
{
    vector<string>::iterator it;
    auto_ptr<vector<string> > loadnames;
    load_t *load;
    int i;
    
    cerr << endl << "Dumping System Loads" << endl;
    
    loadnames = dataNames();
  
    if (dataSize() == 0) {
	cerr << "No Load data in memory" << endl;
	return;
    }
    
    //    namelist[i++] = strdup("Hey Now");
    for (it = loadnames->begin(); it != loadnames->end(); it++) {
	dump(findEntry(*it));
    }
}

void
Loads::dump(struct load *entry)
{
    if (entry) {
	cerr << "Dumping System Load for " << entry->name << endl;
	
	if (entry->name != 0)
	    cerr << "\tIs an " << load_strs[entry->type] << " device";
	else
	    cerr << "\tThere is no device name" << endl;
	
	cerr << " in the " << loadgroup_strs[entry->group] << " category" << endl;
	cerr << "\tThe Voltage is " << entry->voltage;
	cerr << ", the Wattage is " << entry->wattage;
	cerr << ". The Amperage is " << entry->amperage << endl;
	
	if (entry->description != NULL)
	    cerr << "\tThe Description is \"" << entry->description << "\"" << endl;
	else
	    cerr << "\tThere is no description" << endl;
    } else {
	cerr << "ERROR: no entry specified to dump!" << endl;
    }
}

// Dump the data as a comma delimited ASCII text file
void
Loads::writeLoads(string filespec)
{
    ofstream os;
    ostringstream tmpstr;
    int lines = -1;
    vector<string>::iterator it;
    auto_ptr<vector<string> > loadnames;
    load_t *thisload;
    int i;
    char *home;
    string loadfile;
    struct stat stats;
    
    loadnames = dataNames();
    
    if (loadnames->size() == 0) {
	cerr << "No Load data in memory" << endl;
	return;
    }
    
    if (filespec.size() == 0) {

    home = getenv("HOME");
    
    if (home) {
      loadfile = home;
      loadfile += "/.gnuae/loads.csv";
      if (stat(loadfile.c_str(), &stats) == 0) {
        filespec = loadfile;
      } else {
        loadfile = "/etc/gnuae/loads.csv";
        if (stat(loadfile.c_str(), &stats) == 0) {
          filespec = loadfile;
        } else {
          filespec = "./data/loads.csv";
        }
      }
    }
  }

  cout << "Writing load database to:" << filespec << endl;
  
  os.open(filespec.c_str(), ios::out);

  // Write the headers so this can be imported easier into other programs, like a spreadsheet
  os << "\"name\",\"description\",\"type\",\"group\",\"voltage\",\"wattage\",\"amperage\"";
  os << "\"hours\",\"minutes\",\"days\",\"quantity\",\"active\"" << endl;
    
  for (it = loadnames->begin(); it != loadnames->end(); it++) {
    thisload = findEntry(*it);
    os << "\"" << thisload->name << "\",";
    if (thisload->description)
      os << "\"" << thisload->description << "\",";
    else
      os << "\"\",";
    
    os << "\"" << load_strs[thisload->type] << "\",";
    os << "\"" << loadgroup_strs[thisload->group] << "\",";

    os << thisload->voltage << ",";
    os << thisload->wattage << ",";
    os << thisload->amperage << ",";
  }

  os.close();
}

// Read the data from a comma delimited ASCII text file
int
Loads::readLoadsCSV()
{
    return readLoadsCSV("");
}

int
Loads::readLoadsCSV(std::string filespec)
{
    load_t *thisload;
    char buf[LINELEN];
    float val;
    int i;
    ifstream in;
    char *home;
    string tmpbuf, loadfile;
    int lines = -1;
    struct stat stats;
    
    // Set a default data file if not specified.
    if (filespec.empty()) {
	// Get the data directory
	loadfile = gdata.getDataDir();
	loadfile += "/loads.csv";
    } else {
	loadfile = filespec;
    }
    
    cout << "Reading load database from:" << loadfile << endl;
    
    clearData();
    
    // Just use ::open instead of stat to see if the file exists.
    in.open(loadfile.c_str());
    
    if (!in) {
	cerr << "Couldn't open file: " << loadfile << endl;
	return -1;
    }
    
    // Read in but ignore the first line, which are the headers in the
    // data file. We ignore those, cause we *know* what all the fields are.
    in.getline(buf, LINELEN);
    
    while (!in.eof()) {
	lines++;
	// Get memory to hold the data
	thisload = new load_t;
	
	// Read in the name of the load
	in.getline(buf, LINELEN, ','); // Get a token from the line
	tmpbuf = buf;
	if (tmpbuf.size()) {
	    // The string has double quote marks on each end, which is used by
	    // the CSV format. So we drop them to have just the plain string left.
	    tmpbuf.erase(0, 1);
	    tmpbuf.erase(tmpbuf.size()-1, 1);
	    thisload->name = new char[strlen(buf)+1];
	    strcpy((char *)thisload->name, tmpbuf.c_str());
	} else {
	    return lines;
	}
	
	// Read in the description
	in.getline(buf, LINELEN, ','); // Get a token from the line
	tmpbuf = buf;
	
	if (tmpbuf == "\"\"") {
	    thisload->description = NULL;
	} else {
	    if (tmpbuf.size()) {
		// The string has double quote marks on each end, which is used by
		// the CSV format. So we drop them to have just the plain string left.
		tmpbuf.erase(0, 1);
		tmpbuf.erase(tmpbuf.size()-1, 1);
		thisload->description = new char[strlen(buf)+1];
		strcpy((char *)thisload->description, tmpbuf.c_str());
	    } else {
		return lines;
	    }
	}
	
	// Read in the load type. This is either AC or DC
	in.getline(buf, LINELEN, ','); // Get a token from the line
	tmpbuf = buf;
	if (tmpbuf.size()) {
	    // The string has double quote marks on each end, which is used by
	    // the CSV format. So we drop them to have just the plain string left.
	    tmpbuf.erase(0, 1);
	    tmpbuf.erase(tmpbuf.size()-1, 1);
	    if (tmpbuf == "AC")
          thisload->type = AC;
	    else
		thisload->type = DC;
	} else {
	    return lines;
	}
	
	// Read in the load group.
	in.getline(buf, LINELEN, ','); // Get a token from the line
	tmpbuf = buf;
	if (tmpbuf.size()) {
	    // The string has double quote marks on each end, which is used by
	    // the CSV format. So we drop them to have just the plain string left.
	    tmpbuf.erase(0, 1);
	    tmpbuf.erase(tmpbuf.size()-1, 1);
	    if (tmpbuf == "HOUSEHOLD")
		thisload->group = HOUSEHOLD;
	    if (tmpbuf == "DIGITAL")
		thisload->group = DIGITAL;
	    if (tmpbuf == "TOOLS")
		thisload->group = TOOLS;
	    if (tmpbuf == "KITCHEN")
		thisload->group = KITCHEN;
	} else {
	    return lines;
	}
	
	in.getline(buf, LINELEN, ','); // Get a token from the line
	thisload->voltage = strtof(buf, NULL);
	
	in.getline(buf, LINELEN, ','); // Get a token from the line
	thisload->wattage = strtof(buf, NULL);
	
	in.getline(buf, LINELEN, ','); // Get a token from the line
	thisload->amperage = strtof(buf, NULL);
	
	addEntry(thisload);
	//      dump(thisload);
    }
    
    in.close();
    return lines;
}

int
Loads::readLoadsSQL(Database &db)
{
    // DEBUGLOG_REPORT_FUNCTION;
    if (db.getState() == Database::DBOPENED) {
	string query = "SELECT * from loads";
	vector<vector<string> > *result = db.queryResults(query);
	vector<vector<string> >::iterator it;
	for (it=result->begin(); it!=result->end(); ++it) {
	    load_t *thisload = new load_t;
	    vector<string> &row = *it;
	    thisload->name = strdup(row[1].c_str());
	    thisload->description = strdup(row[2].c_str());
	    thisload->manufacturer = strdup(row[3].c_str());
	    if (!row[4].empty()) {
		if (row[4] == "AC") {
		    thisload->type = AC;
		} else if (row[4] == "DC") {
		    thisload->type = DC;
		} else {
		    thisload->type = NOLOAD;
		}
	    }	
	    if (!row[5].empty()) {
		if (row[5] == "HOUSEHOLD") {
		    thisload->group = HOUSEHOLD;
		} else if (row[5] == "TOOLS") {
		    thisload->group = TOOLS;
		} else if (row[5] == "KITCHEN") {
		    thisload->group = KITCHEN;
		} else if (row[5] == "DIGITAL") {
		    thisload->group = DIGITAL;
		} else {
		    thisload->group = UNDEFINED;
		}
	    }
	    thisload->voltage = strtof(row[6].c_str(), NULL);
	    thisload->wattage = strtof(row[7].c_str(), NULL);
	    thisload->amperage = strtof(row[8].c_str(), NULL);
	    addEntry(thisload);
	}
	delete result;
    }

    dbglogfile << "Loaded " << dataSize() << " records from loads table." << endl;

    return dataSize();
}

// Calculated Array values
int
Loads::calcArrayAmps(void)
{
    cerr << "FIXME: unimplemented!" << endl;
}

int
Loads::calcArraySeries(void)
{
    cerr << "FIXME: unimplemented!" << endl;
}

int
Loads::calcArrayParallel(void)
{
    cerr << "FIXME: unimplemented!" << endl;
}

int
Loads::calcArrayTotal(void)
{
    cerr << "FIXME: unimplemented!" << endl;
}


// Calculated Battery values
int
Loads::calcBatteryAmps(void)
{
    cerr << "FIXME: unimplemented!" << endl;
}

int
Loads::calcBatterySeries(void)
{
    cerr << "FIXME: unimplemented!" << endl;
}

int
Loads::calcBatteryParallel(void)
{
    cerr << "FIXME: unimplemented!" << endl;
}

int
Loads::calcBatteryTotal(void)
{
    cerr << "FIXME: unimplemented!" << endl;
}

// Calculate the daily watts used by this device profile
double
Loads::calcWatts(load_t *thisload)
{
    double watts = 0.0, hours;
    
    hours = calcHoursDaily(thisload);
#if 0
    watts = thisload->wattage *  thisload->quantity * hours;
#else
    dbglogfile << __FUNCTION__ << " unimplemented!" << endl;
#endif
    // cerr << thisload->name << ": " << (thisload->wattage *  thisload->quantity *  thisload->days * hours ) / 7 << endl;
    
    return watts;
}

// These are the calculated Values
double
Loads::calcWatts(void)
{
    vector<string>::iterator it;
    auto_ptr<vector<string> > loadnames;
    load_t *thisload;
    double watts = 0.0, hours;
    
    loadnames = dataNames();
    
    if (loadnames->size() == 0) {
	cerr << "No Load data in memory" << endl;
	return 0.0;
    }

#if 1
    cerr << "FIXME: unimplemented!" << endl;
#else
    //    namelist[i++] = strdup("Hey Now");
    for (it = loadnames->begin(); it != loadnames->end(); it++) {
	thisload = findEntry(*it);
	if (thisload->active) {
	    //      hours = thisload->hours + (thisload->minutes/60);
	    watts += calcWatts(thisload); // (thisload->wattage *  thisload->quantity *  thisload->days * hours)/7;
#if 0
	    cerr << "hours = " << thisload->hours << " , minutes = " << thisload->minutes
		 << " sum = " <<  hours << endl;
	    cerr << thisload->name << ": ";
	    cerr << thisload->wattage << " * ";
	    cerr << thisload->quantity << " * ";
	    cerr << thisload->days << " * ";
	    cerr << hours;
	    cerr << thisload->name << ": " << (thisload->wattage *  thisload->quantity *  thisload->days * hours ) / 7;
	    cerr << "watts:\ttotal watts is: " << watts << endl;
#endif
	}
    }
#endif
    
    // Adjust for inefficiencies
    watts *= 1.015;
    
    return watts;
}

double
Loads::calcAmps(load_t *load)
{
    cerr << "FIXME: unimplemented!" << endl;
}

double
Loads::calcAmps(void)
{
    cerr << "FIXME: unimplemented!" << endl;
}


// Calculate the daily watts used by this device profile
double
Loads::calcHoursDaily(load_t *thisload)
{
    double hours = 0.0;
    
    //      hours = thisload->hours + (thisload->minutes/60);
#if 1    
    cerr << "FIXME: unimplemented!" << endl;
#else
    hours = ((thisload->hours + (thisload->minutes/60)) * thisload->days) / 7;
    
#if 0
    cerr << "Hours used daily for " << thisload->name
	 << " is " << hours
	 << ", hours is " << thisload->hours
	 << ", minutes is " << thisload->minutes
	 << ", days is " << thisload->days
	 << endl;
#endif
#endif

    return hours;
}


// These are the calculated Values
double
Loads::calcHoursDaily(void)
{
    vector<string>::iterator it;
    auto_ptr<vector<string> > loadnames;
    load_t *thisload;
    double hours = 0.0;
    
    loadnames = dataNames();
    
    if (loadnames->size() == 0) {
	cerr << "No Load data in memory" << endl;
	return 0.0;
    }

#if 1
    cerr << "FIXME: unimplemented!" << endl;
#else
    //    namelist[i++] = strdup("Hey Now");
    for (it = loadnames->begin(); it != loadnames->end(); it++) {
	thisload = findEntry(*it);
	if (thisload->active) {
	    hours += calcHoursDaily(thisload);
#if 0
	    cerr << "hours = " << thisload->hours << " , minutes = " << thisload->minutes
		 << " sum = " <<  hours << endl;
	    cerr << thisload->name << ": ";
	    cerr << thisload->wattage << " * ";
	    cerr << thisload->quantity << " * ";
	    cerr << thisload->days << " * ";
	    cerr << hours;
	    cerr << minutes;
	    cerr << thisload->name << ": " << (thisload->wattage *  thisload->quantity *  thisload->days * hours ) / 7;
	    cerr << "watts:\ttotal watts is: " << watts << endl;
#endif
	}
    }
#endif
    
    return hours;
}

static Loads _sl;

extern "C" {
    
    void dump_loads(void)
    {
	_sl.dump();
    }
    
    void dump_load(load_t *load)
    {
	_sl.dump(load);
    }
    
    int load_size(void)
    {
	return _sl.dataSize();
    }
    
    int
    load_names(const char **namelist)
    {
	vector<string>::iterator it;
	auto_ptr<vector<string> > loadnames;
	string entry;
	int i = 0;
	
	loadnames = _sl.dataNames();
	
	if (loadnames->size() == 0) {
	    cerr << "No Load data in memory" << endl;
	    return 0;
	}
	
	//    namelist[i++] = strdup("Hey Now");
	for (it = loadnames->begin(); it != loadnames->end(); it++) {
	    entry = *it;
	    namelist[i++] = strdup(entry.c_str());
	    //      dbglog << "NAMELIST " << namelist[i-1] << endl;
	}
	namelist[i++] = "eof";
	
	return i;
    }
    
    // Add a new load into the database
    void add_load(load_t *load)
    {
	_sl.addEntry(load);
    }
    
    // Edit an existing load entry in the database
    void edit_load(load_t *load)
    {
	_sl.editEntry(load);
    }
    
    load_t *find_load(const char *name)
    {
	return _sl.findEntry(name);
    }
    
    int calc_array_amps(void)
    {
	return _sl.calcArrayAmps();
    }
    
    int calc_array_series(void)
    {
	return _sl.calcArraySeries();
    }
    
    int calc_array_parallel(void)
    {
	return _sl.calcArrayParallel();
    }
    
    int calc_array_total(void)
    {
	return _sl.calcArrayTotal();
    }
    
    int calc_battery_amps(void)
    {
	return _sl.calcBatteryAmps();
    }
    
    int calc_battery_series(void)
    {
	return _sl.calcBatterySeries();
    }
    
    int calc_battery_parallel(void)
    {
	return _sl.calcBatteryParallel();
    }
    
    int calc_battery_total(void)
    {
	return _sl.calcBatteryTotal();
    }
    
    double calc_watts_total(void)
    {
	return _sl.calcWatts();
    }
    
    double calc_watts(load_t *load)
    {
	return _sl.calcWatts(load);
    }
    
    double calc_amps_total(void)
    {
	return _sl.calcAmps();
    }
    
    double calc_amps(load_t *load)
    {
	return _sl.calcAmps(load);
    }
    
    double calc_hours_daily_total(void)
    {
	return _sl.calcHoursDaily();
    }
    
    double calc_hours_daily(load_t *load)
    {
	return _sl.calcHoursDaily(load);
    }
    
    void write_loads(const char *filespec) 
    {
	_sl.writeLoads(filespec);
    }
    
    int read_loads_CSV(const char *filespec) 
    {
	return _sl.readLoadsCSV(filespec);
    }
}

} // end of gnuae namespace


// local Variables:
// mode: C++
// indent-tabs-mode: t
// End:
