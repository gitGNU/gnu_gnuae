// 
//   Copyright (C) 2003 Free Software Foundation, Inc.
//
//   This program is free software; you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation; either version 2 of the License, or
//   (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with this program; if not, write to the Free Software
//   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
//

#ifndef __DATATYPE_H__
#define __DATATYPE_H__

// This is generated by autoconf
#include "config.h"

#include <iostream>
#include <vector>
#include <map>
#include <iterator>
#include <string>

#include "Loads.h"

template <class datatype>
class DataTypeMethods
{
 public:
  DataTypeMethods(void)  { };
  ~DataTypeMethods(void) { };  
  
  void addEntry(datatype *entry)
    {
      // _data.insert( make_pair( entry->name, entry) );
      _data[entry->name] = entry;
    }
  void editEntry(datatype *entry)
    {
      _data[entry->name] = entry;
    }
  
  int dataSize(void)
    {
      return _data.size();
    }

  void clearData(void) 
    {
      _data.clear();
    }
  
  datatype *findEntry(std::string name)
    {
      return _data[name];
    }
  
  std::vector<std::string> *dataNames(void)
    {
      // std::map<std::string, datatype *>::const_iterator itttt;
      std::map<std::string, load_t *>::const_iterator it;
      // std::map<std::string, void *>::const_iterator it ;
      std::vector<std::string> *entrynames;
      datatype *entry;
      entrynames = new std::vector<std::string>;  
      
      if (_data.size() == 0) {
        std::cerr << "No Load data in memory!" << std::endl;
        return entrynames;
      }

      for (it = _data.begin(); it != _data.end(); it++) {
        entry = static_cast<datatype *>(it->second);
        entrynames->push_back(entry->name);
      }
      return entrynames;
    }

  void addData (void)
    {
#if 0
      int i;

      for (i=0; loads[i].name!=0; i++)
        {
          _data.insert( make_pair( loads[i].name, (load_t *)&loads[i]) );
          //      _data.push_back(&loads[i]);
        }
#endif
    }
  
#if 0
  datatype *operator [] (std::string name)
    {
      return _data[name];
    }
#endif   
 private:
  std::map<std::string, datatype *> _data;
};

// __DATATYPE_H__
#endif
